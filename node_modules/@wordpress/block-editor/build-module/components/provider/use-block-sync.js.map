{"version":3,"sources":["@wordpress/block-editor/src/components/provider/use-block-sync.js"],"names":["last","noop","useEffect","useRef","useRegistry","useSelect","cloneBlock","store","blockEditorStore","useBlockSync","clientId","value","controlledBlocks","selection","controlledSelection","onChange","onInput","registry","resetBlocks","resetSelection","replaceInnerBlocks","setHasControlledInnerBlocks","__unstableMarkNextChangeAsNotPersistent","dispatch","getBlockName","getBlocks","select","isControlled","areInnerBlocksControlled","pendingChanges","incoming","outgoing","subscribed","setControlledBlocks","batch","storeBlocks","map","block","current","onInputRef","onChangeRef","includes","selectionStart","selectionEnd","initialPosition","getSelectionStart","getSelectionEnd","getSelectedBlocksInitialCaretPosition","isLastBlockChangePersistent","__unstableIsLastBlockChangeIgnored","blocks","isPersistent","previousAreBlocksDifferent","unsubscribe","subscribe","isStillControlled","newIsPersistent","newBlocks","areBlocksDifferent","didPersistenceChange","push","updateParent"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { last, noop } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { useEffect, useRef } from '@wordpress/element';\nimport { useRegistry, useSelect } from '@wordpress/data';\nimport { cloneBlock } from '@wordpress/blocks';\n\n/**\n * Internal dependencies\n */\nimport { store as blockEditorStore } from '../../store';\n\n/**\n * A function to call when the block value has been updated in the block-editor\n * store.\n *\n * @callback onBlockUpdate\n * @param {Object[]} blocks  The updated blocks.\n * @param {Object}   options The updated block options, such as selectionStart\n *                           and selectionEnd.\n */\n\n/**\n * useBlockSync is a side effect which handles bidirectional sync between the\n * block-editor store and a controlling data source which provides blocks. This\n * is most commonly used by the BlockEditorProvider to synchronize the contents\n * of the block-editor store with the root entity, like a post.\n *\n * Another example would be the template part block, which provides blocks from\n * a separate entity data source than a root entity. This hook syncs edits to\n * the template part in the block editor back to the entity and vice-versa.\n *\n * Here are some of its basic functions:\n * - Initalizes the block-editor store for the given clientID to the blocks\n *   given via props.\n * - Adds incoming changes (like undo) to the block-editor store.\n * - Adds outgoing changes (like editing content) to the controlling entity,\n *   determining if a change should be considered persistent or not.\n * - Handles edge cases and race conditions which occur in those operations.\n * - Ignores changes which happen to other entities (like nested inner block\n *   controllers.\n * - Passes selection state from the block-editor store to the controlling entity.\n *\n * @param {Object}        props           Props for the block sync hook\n * @param {string}        props.clientId  The client ID of the inner block controller.\n *                                        If none is passed, then it is assumed to be a\n *                                        root controller rather than an inner block\n *                                        controller.\n * @param {Object[]}      props.value     The control value for the blocks. This value\n *                                        is used to initalize the block-editor store\n *                                        and for resetting the blocks to incoming\n *                                        changes like undo.\n * @param {Object}        props.selection The selection state responsible to restore the selection on undo/redo.\n * @param {onBlockUpdate} props.onChange  Function to call when a persistent\n *                                        change has been made in the block-editor blocks\n *                                        for the given clientId. For example, after\n *                                        this function is called, an entity is marked\n *                                        dirty because it has changes to save.\n * @param {onBlockUpdate} props.onInput   Function to call when a non-persistent\n *                                        change has been made in the block-editor blocks\n *                                        for the given clientId. When this is called,\n *                                        controlling sources do not become dirty.\n */\nexport default function useBlockSync( {\n\tclientId = null,\n\tvalue: controlledBlocks,\n\tselection: controlledSelection,\n\tonChange = noop,\n\tonInput = noop,\n} ) {\n\tconst registry = useRegistry();\n\n\tconst {\n\t\tresetBlocks,\n\t\tresetSelection,\n\t\treplaceInnerBlocks,\n\t\tsetHasControlledInnerBlocks,\n\t\t__unstableMarkNextChangeAsNotPersistent,\n\t} = registry.dispatch( blockEditorStore );\n\tconst { getBlockName, getBlocks } = registry.select( blockEditorStore );\n\tconst isControlled = useSelect(\n\t\t( select ) => {\n\t\t\treturn (\n\t\t\t\t! clientId ||\n\t\t\t\tselect( blockEditorStore ).areInnerBlocksControlled( clientId )\n\t\t\t);\n\t\t},\n\t\t[ clientId ]\n\t);\n\n\tconst pendingChanges = useRef( { incoming: null, outgoing: [] } );\n\tconst subscribed = useRef( false );\n\n\tconst setControlledBlocks = () => {\n\t\tif ( ! controlledBlocks ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't need to persist this change because we only replace\n\t\t// controlled inner blocks when the change was caused by an entity,\n\t\t// and so it would already be persisted.\n\t\t__unstableMarkNextChangeAsNotPersistent();\n\t\tif ( clientId ) {\n\t\t\t// It is important to batch here because otherwise,\n\t\t\t// as soon as `setHasControlledInnerBlocks` is called\n\t\t\t// the effect to restore might be triggered\n\t\t\t// before the actual blocks get set properly in state.\n\t\t\tregistry.batch( () => {\n\t\t\t\tsetHasControlledInnerBlocks( clientId, true );\n\t\t\t\tconst storeBlocks = controlledBlocks.map( ( block ) =>\n\t\t\t\t\tcloneBlock( block )\n\t\t\t\t);\n\t\t\t\tif ( subscribed.current ) {\n\t\t\t\t\tpendingChanges.current.incoming = storeBlocks;\n\t\t\t\t}\n\t\t\t\t__unstableMarkNextChangeAsNotPersistent();\n\t\t\t\treplaceInnerBlocks( clientId, storeBlocks );\n\t\t\t} );\n\t\t} else {\n\t\t\tif ( subscribed.current ) {\n\t\t\t\tpendingChanges.current.incoming = controlledBlocks;\n\t\t\t}\n\t\t\tresetBlocks( controlledBlocks );\n\t\t}\n\t};\n\n\t// Add a subscription to the block-editor registry to detect when changes\n\t// have been made. This lets us inform the data source of changes. This\n\t// is an effect so that the subscriber can run synchronously without\n\t// waiting for React renders for changes.\n\tconst onInputRef = useRef( onInput );\n\tconst onChangeRef = useRef( onChange );\n\tuseEffect( () => {\n\t\tonInputRef.current = onInput;\n\t\tonChangeRef.current = onChange;\n\t}, [ onInput, onChange ] );\n\n\t// Determine if blocks need to be reset when they change.\n\tuseEffect( () => {\n\t\tif ( pendingChanges.current.outgoing.includes( controlledBlocks ) ) {\n\t\t\t// Skip block reset if the value matches expected outbound sync\n\t\t\t// triggered by this component by a preceding change detection.\n\t\t\t// Only skip if the value matches expectation, since a reset should\n\t\t\t// still occur if the value is modified (not equal by reference),\n\t\t\t// to allow that the consumer may apply modifications to reflect\n\t\t\t// back on the editor.\n\t\t\tif (\n\t\t\t\tlast( pendingChanges.current.outgoing ) === controlledBlocks\n\t\t\t) {\n\t\t\t\tpendingChanges.current.outgoing = [];\n\t\t\t}\n\t\t} else if ( getBlocks( clientId ) !== controlledBlocks ) {\n\t\t\t// Reset changing value in all other cases than the sync described\n\t\t\t// above. Since this can be reached in an update following an out-\n\t\t\t// bound sync, unset the outbound value to avoid considering it in\n\t\t\t// subsequent renders.\n\t\t\tpendingChanges.current.outgoing = [];\n\t\t\tsetControlledBlocks();\n\n\t\t\tif ( controlledSelection ) {\n\t\t\t\tresetSelection(\n\t\t\t\t\tcontrolledSelection.selectionStart,\n\t\t\t\t\tcontrolledSelection.selectionEnd,\n\t\t\t\t\tcontrolledSelection.initialPosition\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}, [ controlledBlocks, clientId ] );\n\n\tuseEffect( () => {\n\t\t// When the block becomes uncontrolled, it means its inner state has been reset\n\t\t// we need to take the blocks again from the external value property.\n\t\tif ( ! isControlled ) {\n\t\t\tpendingChanges.current.outgoing = [];\n\t\t\tsetControlledBlocks();\n\t\t}\n\t}, [ isControlled ] );\n\n\tuseEffect( () => {\n\t\tconst {\n\t\t\tgetSelectionStart,\n\t\t\tgetSelectionEnd,\n\t\t\tgetSelectedBlocksInitialCaretPosition,\n\t\t\tisLastBlockChangePersistent,\n\t\t\t__unstableIsLastBlockChangeIgnored,\n\t\t\tareInnerBlocksControlled,\n\t\t} = registry.select( blockEditorStore );\n\n\t\tlet blocks = getBlocks( clientId );\n\t\tlet isPersistent = isLastBlockChangePersistent();\n\t\tlet previousAreBlocksDifferent = false;\n\n\t\tsubscribed.current = true;\n\t\tconst unsubscribe = registry.subscribe( () => {\n\t\t\t// Sometimes, when changing block lists, lingering subscriptions\n\t\t\t// might trigger before they are cleaned up. If the block for which\n\t\t\t// the subscription runs is no longer in the store, this would clear\n\t\t\t// its parent entity's block list. To avoid this, we bail out if\n\t\t\t// the subscription is triggering for a block (`clientId !== null`)\n\t\t\t// and its block name can't be found because it's not on the list.\n\t\t\t// (`getBlockName( clientId ) === null`).\n\t\t\tif ( clientId !== null && getBlockName( clientId ) === null )\n\t\t\t\treturn;\n\n\t\t\t// When RESET_BLOCKS on parent blocks get called, the controlled blocks\n\t\t\t// can reset to uncontrolled, in these situations, it means we need to populate\n\t\t\t// the blocks again from the external blocks (the value property here)\n\t\t\t// and we should stop triggering onChange\n\t\t\tconst isStillControlled =\n\t\t\t\t! clientId || areInnerBlocksControlled( clientId );\n\t\t\tif ( ! isStillControlled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newIsPersistent = isLastBlockChangePersistent();\n\t\t\tconst newBlocks = getBlocks( clientId );\n\t\t\tconst areBlocksDifferent = newBlocks !== blocks;\n\t\t\tblocks = newBlocks;\n\n\t\t\tif (\n\t\t\t\tareBlocksDifferent &&\n\t\t\t\t( pendingChanges.current.incoming ||\n\t\t\t\t\t__unstableIsLastBlockChangeIgnored() )\n\t\t\t) {\n\t\t\t\tpendingChanges.current.incoming = null;\n\t\t\t\tisPersistent = newIsPersistent;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Since we often dispatch an action to mark the previous action as\n\t\t\t// persistent, we need to make sure that the blocks changed on the\n\t\t\t// previous action before committing the change.\n\t\t\tconst didPersistenceChange =\n\t\t\t\tpreviousAreBlocksDifferent &&\n\t\t\t\t! areBlocksDifferent &&\n\t\t\t\tnewIsPersistent &&\n\t\t\t\t! isPersistent;\n\n\t\t\tif ( areBlocksDifferent || didPersistenceChange ) {\n\t\t\t\tisPersistent = newIsPersistent;\n\t\t\t\t// We know that onChange/onInput will update controlledBlocks.\n\t\t\t\t// We need to be aware that it was caused by an outgoing change\n\t\t\t\t// so that we do not treat it as an incoming change later on,\n\t\t\t\t// which would cause a block reset.\n\t\t\t\tpendingChanges.current.outgoing.push( blocks );\n\n\t\t\t\t// Inform the controlling entity that changes have been made to\n\t\t\t\t// the block-editor store they should be aware about.\n\t\t\t\tconst updateParent = isPersistent\n\t\t\t\t\t? onChangeRef.current\n\t\t\t\t\t: onInputRef.current;\n\t\t\t\tupdateParent( blocks, {\n\t\t\t\t\tselection: {\n\t\t\t\t\t\tselectionStart: getSelectionStart(),\n\t\t\t\t\t\tselectionEnd: getSelectionEnd(),\n\t\t\t\t\t\tinitialPosition: getSelectedBlocksInitialCaretPosition(),\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t\tpreviousAreBlocksDifferent = areBlocksDifferent;\n\t\t} );\n\n\t\treturn () => unsubscribe();\n\t}, [ registry, clientId ] );\n}\n"]}