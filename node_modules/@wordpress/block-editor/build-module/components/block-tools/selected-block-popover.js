import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { find } from 'lodash';
import classnames from 'classnames';
/**
 * WordPress dependencies
 */

import { useState, useRef, useEffect } from '@wordpress/element';
import { isUnmodifiedDefaultBlock } from '@wordpress/blocks';
import { useDispatch, useSelect } from '@wordpress/data';
import { useShortcut } from '@wordpress/keyboard-shortcuts';
import { useViewportMatch } from '@wordpress/compose';
/**
 * Internal dependencies
 */

import BlockSelectionButton from './block-selection-button';
import BlockContextualToolbar from './block-contextual-toolbar';
import Inserter from '../inserter';
import { store as blockEditorStore } from '../../store';
import BlockPopover from '../block-popover';

function selector(select) {
  const {
    isNavigationMode,
    isMultiSelecting,
    hasMultiSelection,
    isTyping,
    getSettings,
    getLastMultiSelectedBlockClientId
  } = select(blockEditorStore);
  return {
    isNavigationMode: isNavigationMode(),
    isMultiSelecting: isMultiSelecting(),
    isTyping: isTyping(),
    hasFixedToolbar: getSettings().hasFixedToolbar,
    lastClientId: hasMultiSelection() ? getLastMultiSelectedBlockClientId() : null
  };
}

function SelectedBlockPopover(_ref) {
  let {
    clientId,
    rootClientId,
    isEmptyDefaultBlock,
    capturingClientId,
    __unstablePopoverSlot,
    __unstableContentRef
  } = _ref;
  const {
    isNavigationMode,
    isMultiSelecting,
    isTyping,
    hasFixedToolbar,
    lastClientId
  } = useSelect(selector, []);
  const isInsertionPointVisible = useSelect(select => {
    const {
      isBlockInsertionPointVisible,
      getBlockInsertionPoint,
      getBlockOrder
    } = select(blockEditorStore);

    if (!isBlockInsertionPointVisible()) {
      return false;
    }

    const insertionPoint = getBlockInsertionPoint();
    const order = getBlockOrder(insertionPoint.rootClientId);
    return order[insertionPoint.index] === clientId;
  }, [clientId]);
  const isLargeViewport = useViewportMatch('medium');
  const isToolbarForced = useRef(false);
  const [isInserterShown, setIsInserterShown] = useState(false);
  const {
    stopTyping
  } = useDispatch(blockEditorStore);
  const showEmptyBlockSideInserter = !isTyping && !isNavigationMode && isEmptyDefaultBlock;
  const shouldShowBreadcrumb = isNavigationMode;
  const shouldShowContextualToolbar = !isNavigationMode && !hasFixedToolbar && isLargeViewport && !isMultiSelecting && !showEmptyBlockSideInserter && !isTyping;
  const canFocusHiddenToolbar = !isNavigationMode && !shouldShowContextualToolbar && !hasFixedToolbar && !isEmptyDefaultBlock;
  useShortcut('core/block-editor/focus-toolbar', () => {
    isToolbarForced.current = true;
    stopTyping(true);
  }, {
    isDisabled: !canFocusHiddenToolbar
  });
  useEffect(() => {
    isToolbarForced.current = false;
  }); // Stores the active toolbar item index so the block toolbar can return focus
  // to it when re-mounting.

  const initialToolbarItemIndexRef = useRef();

  if (!shouldShowBreadcrumb && !shouldShowContextualToolbar) {
    return null;
  }

  function onFocus() {
    setIsInserterShown(true);
  }

  function onBlur() {
    setIsInserterShown(false);
  }

  return createElement(BlockPopover, {
    clientId: capturingClientId || clientId,
    bottomClientId: lastClientId,
    className: classnames('block-editor-block-list__block-popover', {
      'is-insertion-point-visible': isInsertionPointVisible
    }),
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  }, shouldShowContextualToolbar && createElement("div", {
    onFocus: onFocus,
    onBlur: onBlur // While ideally it would be enough to capture the
    // bubbling focus event from the Inserter, due to the
    // characteristics of click focusing of `button`s in
    // Firefox and Safari, it is not reliable.
    //
    // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
    ,
    tabIndex: -1,
    className: classnames('block-editor-block-list__block-popover-inserter', {
      'is-visible': isInserterShown
    })
  }, createElement(Inserter, {
    clientId: clientId,
    rootClientId: rootClientId,
    __experimentalIsQuick: true
  })), shouldShowContextualToolbar && createElement(BlockContextualToolbar // If the toolbar is being shown because of being forced
  // it should focus the toolbar right after the mount.
  , {
    focusOnMount: isToolbarForced.current,
    __experimentalInitialIndex: initialToolbarItemIndexRef.current,
    __experimentalOnIndexChange: index => {
      initialToolbarItemIndexRef.current = index;
    } // Resets the index whenever the active block changes so
    // this is not persisted. See https://github.com/WordPress/gutenberg/pull/25760#issuecomment-717906169
    ,
    key: clientId
  }), shouldShowBreadcrumb && createElement(BlockSelectionButton, {
    clientId: clientId,
    rootClientId: rootClientId
  }));
}

function wrapperSelector(select) {
  const {
    getSelectedBlockClientId,
    getFirstMultiSelectedBlockClientId,
    getBlockRootClientId,
    getBlock,
    getBlockParents,
    __experimentalGetBlockListSettingsForBlocks
  } = select(blockEditorStore);
  const clientId = getSelectedBlockClientId() || getFirstMultiSelectedBlockClientId();

  if (!clientId) {
    return;
  }

  const {
    name,
    attributes = {}
  } = getBlock(clientId) || {};
  const blockParentsClientIds = getBlockParents(clientId); // Get Block List Settings for all ancestors of the current Block clientId.

  const parentBlockListSettings = __experimentalGetBlockListSettingsForBlocks(blockParentsClientIds); // Get the clientId of the topmost parent with the capture toolbars setting.


  const capturingClientId = find(blockParentsClientIds, parentClientId => {
    var _parentBlockListSetti;

    return (_parentBlockListSetti = parentBlockListSettings[parentClientId]) === null || _parentBlockListSetti === void 0 ? void 0 : _parentBlockListSetti.__experimentalCaptureToolbars;
  });
  return {
    clientId,
    rootClientId: getBlockRootClientId(clientId),
    name,
    isEmptyDefaultBlock: name && isUnmodifiedDefaultBlock({
      name,
      attributes
    }),
    capturingClientId
  };
}

export default function WrappedBlockPopover(_ref2) {
  let {
    __unstablePopoverSlot,
    __unstableContentRef
  } = _ref2;
  const selected = useSelect(wrapperSelector, []);

  if (!selected) {
    return null;
  }

  const {
    clientId,
    rootClientId,
    name,
    isEmptyDefaultBlock,
    capturingClientId
  } = selected;

  if (!name) {
    return null;
  }

  return createElement(SelectedBlockPopover, {
    clientId: clientId,
    rootClientId: rootClientId,
    isEmptyDefaultBlock: isEmptyDefaultBlock,
    capturingClientId: capturingClientId,
    __unstablePopoverSlot: __unstablePopoverSlot,
    __unstableContentRef: __unstableContentRef
  });
}
//# sourceMappingURL=selected-block-popover.js.map